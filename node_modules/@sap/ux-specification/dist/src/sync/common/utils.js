"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("../../specification/common");
const edmx_parser_1 = require("@sap-ux/edmx-parser");
const annotation_converter_1 = require("@sap-ux/annotation-converter");
/**
 * Parses, merges, and converts a list of annotation files with aid of tools from annotation-vocabularies-tools
 * @param annotationFiles
 * @returns the typed entity types with annotations
 */
function parseAndMergeAndConvert(annotationFiles) {
    const parseResult = [];
    if (annotationFiles) {
        annotationFiles.forEach(function (annotationData) {
            parseResult.push(edmx_parser_1.parseEDMX(annotationData.fileContent, annotationData.dataSourceUri));
        });
    }
    const service = annotation_converter_1.convertTypes(edmx_parser_1.merge(parseResult));
    return service.entityTypes;
}
exports.parseAndMergeAndConvert = parseAndMergeAndConvert;
exports.getManifestSectionByPathV4 = (exportResultManifest, path, targetAnnotation, targetAnnotationEncoded) => {
    let exportResultSection = exportResultManifest;
    path.split('/').forEach(function (element) {
        if (targetAnnotationEncoded && targetAnnotationEncoded === element) {
            element = targetAnnotation;
        }
        if (!exportResultSection[element]) {
            exportResultSection[element] = {};
        }
        exportResultSection = exportResultSection[element];
    });
    return exportResultSection;
};
exports.getAnnotationPropertyValue = (annotationProperty) => annotationProperty.value || annotationProperty.path;
/**
 * The function parses the line item annotation and returns a list of keys, one for each record.
 * It simulates the work of the V2 StableIdHelper, as it calculates the last section of the stable ID.
 * Note: no leading 'template:::TableColumn:::' is added for this last section, for easier reading.
 * This corresponds to the import logic at src/sync/v2/import/controls/table.ts.
 * The string 'template:::TableColumn:::' must be added for flex changes during the export.
 *
 * @param annotationTerm - object of the line item annotation
 * @returns items - Array of keys, each representig the last part of the stable id of a line item record
 */
function getLineItemsTyped(annotationTerm) {
    const items = [];
    let target;
    let value;
    annotationTerm.forEach((lineItemRecord) => {
        let n;
        switch (lineItemRecord.$Type) {
            case "com.sap.vocabularies.UI.v1.DataField" /* DataField */:
                value = exports.getAnnotationPropertyValue(lineItemRecord.Value);
                if (value) {
                    items.push(value.replace(new RegExp('/', 'g'), '_'));
                }
                break;
            case "com.sap.vocabularies.UI.v1.DataFieldWithUrl" /* DataFieldWithUrl */:
                value =
                    typeof lineItemRecord.Value === 'string'
                        ? lineItemRecord.Value
                        : exports.getAnnotationPropertyValue(lineItemRecord.Value);
                if (value) {
                    items.push(value.replace(new RegExp('/', 'g'), '_'));
                }
                break;
            case "com.sap.vocabularies.UI.v1.DataFieldForAnnotation" /* DataFieldForAnnotation */:
                target = lineItemRecord.Target.value;
                n = target.lastIndexOf('/');
                if (n >= 0) {
                    target = target.substring(0, n) + '/@' + target.substring(n + 1);
                }
                items.push('DataFieldForAnnotation:::sTarget::' +
                    target
                        .replace('@UI', '@com.sap.vocabularies.UI.v1')
                        .replace('@Communication', '@com.sap.vocabularies.Communication.v1'));
                break;
            case "com.sap.vocabularies.UI.v1.DataFieldForAction" /* DataFieldForAction */:
                if (lineItemRecord.Inline) {
                    items.push('DataFieldForAction:::sAction::' + lineItemRecord.Action);
                }
                break;
            case "com.sap.vocabularies.UI.v1.DataFieldWithIntentBasedNavigation" /* DataFieldWithIntentBasedNavigation */:
                value = exports.getAnnotationPropertyValue(lineItemRecord.Value);
                items.push('DataFieldWithIntentBasedNavigation:::sProperty::' +
                    value +
                    ':::sSemanticObject::' +
                    lineItemRecord.SemanticObject +
                    ':::sAction::' +
                    lineItemRecord.Action);
                break;
            case "com.sap.vocabularies.UI.v1.DataFieldForIntentBasedNavigation" /* DataFieldForIntentBasedNavigation */:
                if (lineItemRecord.Inline) {
                    items.push('DataFieldForIntentBasedNavigation:::sSemanticObject::' +
                        lineItemRecord.SemanticObject +
                        ':::sAction::' +
                        lineItemRecord.Action);
                }
                break;
            case "com.sap.vocabularies.UI.v1.DataFieldWithNavigationPath" /* DataFieldWithNavigationPath */:
                value = exports.getAnnotationPropertyValue(lineItemRecord.Value);
                target = exports.getAnnotationPropertyValue(lineItemRecord.Target);
                items.push('DataFieldWithNavigationPath:::sProperty::' + value + ':::sTarget::' + target);
                break;
            default:
                break;
        }
    });
    return items;
}
exports.getLineItemsTyped = getLineItemsTyped;
/**
 * Evvaluates the target annotation of a reference facet and actualizes the facets for the config
 * @param annotationRecord - the actual annotation record
 * @param facets - list of facets in config format, to be updated
 * @param service - the service metadata of the app
 * @param serviceName - name of the service of the app
 * @param entityName - the entity (type) name
 * @param entityTypes - entity types, as delivered by parse & merge & convert
 */
function evaluateTargetAnnotation(annotationRecord, facets, serviceName, entityName, entityTypes) {
    const path = annotationRecord.Target.value;
    if (path.includes('@UI.Chart')) {
        facets[path] = { base: 'ChartFacet' };
    }
    else if (path.includes('@UI.LineItem')) {
        facets[path] = { base: 'LineItemFacet' };
        const entityType = entityTypes.find((e) => e.fullyQualifiedName === `${serviceName}.${entityName}`);
        if (entityType) {
            //ToDo: handle scenarios with multiple navigations
            const targetEntity = entityType.navigationProperties.find((n) => n.name === path.split('/')[0])
                .targetType.fullyQualifiedName;
            const [scope, annotation] = path
                .split('/')[1]
                .replace('@', '')
                .split('.');
            const targetEntityType = entityTypes.find((et) => et.fullyQualifiedName === targetEntity);
            if (targetEntityType &&
                targetEntityType.annotations &&
                targetEntityType.annotations[scope] &&
                targetEntityType.annotations[scope][annotation]) {
                facets[path].lineItem = getLineItemsTyped(targetEntityType.annotations[scope][annotation]);
            }
        }
    }
    else {
        facets[path] = { base: 'FormFacet' };
    }
    // Add Facet ID
    if (facets[path]) {
        if (annotationRecord.ID) {
            facets[path]['ID'] = annotationRecord.ID;
        }
    }
}
/**
 * Adds the information from facets to the config
 * @param annotationRecord - the actual annotation record
 * @param entityTypes - entity types, as delivered by parse & merge & convert
 * @param service - the service metadata of the app
 * @param serviceName - name of the service of the app
 * @param entityName - the entity (type) name
 * @param facets - list of facets in config format, to be updated
 */
function addFacetToConfig(annotationRecord, entityTypes, serviceName, entityName, facets) {
    switch (annotationRecord.$Type) {
        case "com.sap.vocabularies.UI.v1.ReferenceFacet" /* ReferenceFacet */: {
            evaluateTargetAnnotation(annotationRecord, facets, serviceName, entityName, entityTypes);
            break;
        }
        case "com.sap.vocabularies.UI.v1.CollectionFacet" /* CollectionFacet */: {
            annotationRecord.Facets.forEach((collectionItem) => {
                addFacetToConfig(collectionItem, entityTypes, serviceName, entityName, facets);
            });
            break;
        }
    }
}
/**
 * Retrieve facet configurations that can be used to generate ObjectPage schemas
 * @param entitySet - the actual entitySet (corresponds to the given page)
 * @param entityTypes - annotation schema, as delivered by parse & merge & convert
 * @param service - the given service metadata
 */
function getObjectPageFacets(entitySet, entityTypes) {
    const facets = {};
    const entityType = entityTypes.find((et) => et.name === entitySet);
    const facetAnnotation = entityType.annotations.UI.Facets;
    if (facetAnnotation) {
        const [serviceName, entityName] = entityType.fullyQualifiedName.split('.');
        facetAnnotation.forEach((item) => {
            addFacetToConfig(item, entityTypes, serviceName, entityName, facets);
        });
    }
    return facets;
}
exports.getObjectPageFacets = getObjectPageFacets;
/**
 * Returns the version of Fiori elements (v2/v4) from a given manifest
 * @param manifest - the manifest.json file
 */
function getVersionFromManifest(manifest) {
    if (manifest['sap.ui.generic.app'] || manifest['sap.ovp']) {
        return common_1.FioriElementsVersion.v2;
    }
    else {
        return common_1.FioriElementsVersion.v4;
    }
}
exports.getVersionFromManifest = getVersionFromManifest;
/**
 * Method adds definition for 'RelatedFacetKeys' as enum with describtion and adds references to 'RelatedFacetKeys' for custom section definitions.
 * @param {object} schema App specific schema that potentially gets enhanced
 * @param {string[]>} sectionDefinitions array of section definitions which should be updated with new reference to 'RelatedFacetKeys' enum.
 * @param {FacetSection[]} facetSections Array of facet section objects which is used to generate enum values.
 */
function addDefinitionForRelatedFacetKeys(schema, sectionDefinitions, facetSections) {
    // Create new definition in schema as 'oneOf'.
    // Simpler way would be to use 'enum', but then there no option to pass description.
    schema['definitions']['RelatedFacetKeys'] = {
        type: 'string',
        oneOf: facetSections.map((section) => {
            return {
                const: section.key,
                ...(section.label && { description: section.label }),
                ...(section.custom && { custom: section.custom })
            };
        })
    };
    // Add enum definition
    for (const name of sectionDefinitions) {
        const definition = schema['definitions'][name];
        const property = definition['properties']['relatedFacet'];
        definition['properties']['relatedFacet'] = {
            anyOf: [
                {
                    $ref: '#/definitions/RelatedFacetKeys'
                },
                property
            ]
        };
    }
}
exports.addDefinitionForRelatedFacetKeys = addDefinitionForRelatedFacetKeys;
/**
 * Retrieve page section data(so far id/key and label/description).
 * @param {QualifiedName} entitySet The actual entitySet (corresponds to the given page)
 * @param {EntityType[]} entityTypes Entity types, as delivered by parse & merge & convert
 * @param {Function} resolve Resolver method. Specific method passed from outside, because V2 and V4 have different logic to resolve ids/keys.
 * @return {FacetSection[]} Array of FacetSection objects.
 */
function getObjectPageFacetSection(entitySet, entityTypes, resolve) {
    const entityType = entityTypes.find((et) => et.name === entitySet);
    const facetAnnotation = entityType.annotations.UI.Facets;
    if (!facetAnnotation) {
        return [];
    }
    return facetAnnotation.reduce(function (result, item, index) {
        const section = resolve(item, index);
        if (section) {
            result.push(section);
        }
        return result;
    }, []);
}
exports.getObjectPageFacetSection = getObjectPageFacetSection;
exports.deleteEmptyStructure = (manifest, path) => {
    let manifestSection = manifest;
    path.split('/').forEach(function (element) {
        if (!manifestSection[element]) {
            return;
        }
        if (Object.keys(manifestSection[element]).length === 0) {
            delete manifestSection[element];
            return;
        }
        manifestSection = manifestSection && manifestSection[element];
    });
};
//# sourceMappingURL=utils.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const pages_1 = require("./pages");
const decorators_1 = require("../../common/decoration/decorators");
const controls_1 = require("./controls");
const AnalyticalListPageChart_1 = require("../../../sync/v2/export/controls/AnalyticalListPageChart");
const page_1 = require("../../../specification/common/page");
const v2_1 = require("../../../v2");
const application_1 = require("../application");
const manifest_1 = require("./manifest");
const utils_1 = require("../import/utils");
const Card_1 = require("../../../specification/v2/controls/Card");
const common_1 = require("../../common");
/**
 * Returns a fresh export results object with default values
 */
const getDefaultExportResult = () => ({
    flexChanges: [],
    manifest: {
        'sap.ui.generic.app': { pages: {} }
    }
});
/**
 * Recursive function that searches for next avaialble id by increasing number by 1.
 * @param {boolean} sectionIds All ids in use.
 * @param {string} candidateId Candidate id to check if it is available.
 * @return {string} Id string.
 */
function findAvailableId(sectionIds, candidateId) {
    if (sectionIds.includes(candidateId)) {
        const idParts = candidateId.split('|');
        if (idParts.length === 3) {
            idParts.push('1');
        }
        else {
            idParts[3] = (parseInt(idParts[3]) + 1).toString();
        }
        return findAvailableId(sectionIds, idParts.join('|'));
    }
    return candidateId;
}
/**
 * Recursive function that traverses the content of the current object. It reads decorators and fills manifest entries and flex changes
 * @param configSections - sections from configuration object
 * @param pageKey  - page key
 * @param fullManifest - full manifest object
 * @param parentIds - array of collected parent ids
 * @param manifest - app descriptor (manifest.json)
 * @param breadcrumbs - array of properties that we are currently processing. Required for instance for table column name
 * @param exportResults - object with all collected manifest entries and flex changes
 * @param appId - id of the Fiori elements app, which is usually namespace.appid
 * @param baseId - selector id of the current page
 * @param pageKeys - array of keys to identify component in manifest
 * @param jsonSchema - application specific schema
 * @param targetDefinition - the current entry point or definition in the app schema
 * @param entityAnnotations - list of annotations of the entity type that the page is referring to
 */
function transferManifestExtensions(configSections, pageKey, fullManifest, parentIds, manifest, breadcrumbs, exportResults, appId, baseId, pageKeys, jsonSchema, targetDefinition) {
    const sectionIds = [];
    const entity = pageKey.split('|')[1];
    for (const section of configSections) {
        const id = findAvailableId(sectionIds, [section.relativePosition, entity, section.relatedFacet].join('|'));
        sectionIds.push(id);
    }
    for (const index in sectionIds) {
        const definition = targetDefinition['anyOf'].find((element) => element.$ref.includes(configSections[index].constructor.name));
        const definitionArray = definition.$ref.split('#/definitions/');
        const nextTargetDefinition = jsonSchema['definitions'][definitionArray[definitionArray.length - 1]];
        transferManifestEntriesAndFlexChange(fullManifest, configSections[index], parentIds, manifest, [...breadcrumbs, sectionIds[index]], exportResults, appId, baseId, pageKeys, jsonSchema, nextTargetDefinition);
    }
    // Delete removed manifest entries
    const manifestSections = manifest_1.getManifestSectionByPathV2(exportResults.manifest, application_1.getViewExtensionsPath());
    for (const key in manifestSections) {
        if (!sectionIds.includes(key)) {
            delete manifestSections[key];
        }
    }
}
/**
 * Recursive function that traverses the content of the current object. It reads decorators and fills manifest entries and flex changes
 * @param object - current object to traverse
 * @param parentIds - array of collected parent ids
 * @param manifest - app descriptor (manifest.json)
 * @param breadcrumbs - array of properties that we are currently processing. Required for instance for table column name
 * @param exportResults - object with all collected manifest entries and flex changes
 * @param appId - id of the Fiori elements app, which is usually namespace.appid
 * @param baseId - selector id of the current page
 * @param pageKeys - array of keys to identify component in manifest
 * @param jsonSchema - application specific schema
 * @param targetDefinition - the current entry point or definition in the app schema
 * @param entityAnnotations - list of annotations of the entity type that the page is referring to
 */
function transferManifestEntriesAndFlexChange(fullManifest, object, parentIds, manifest, breadcrumbs, exportResults, appId, baseId, pageKeys, jsonSchema, targetDefinition, title) {
    let manifestSection, localBreadcrumbs = [];
    if (targetDefinition && targetDefinition['properties']) {
        for (const key in targetDefinition['properties']) {
            const childId = decorators_1.getChildId(object, key);
            const ids = childId ? [...parentIds, childId] : parentIds;
            const exportPropertyRule = decorators_1.getExportRuleMetadata(object, key);
            if (exportPropertyRule) {
                if (exportPropertyRule.flex) {
                    if (object[key] !== undefined) {
                        if (breadcrumbs.length === 0) {
                            //only added on top = page level, do not forward
                            localBreadcrumbs = ['page'];
                        }
                        else {
                            localBreadcrumbs = breadcrumbs;
                        }
                        const flexChange = {
                            controlId: exportPropertyRule.flex.controlId(baseId, ids, localBreadcrumbs, exportPropertyRule.flex.controlType, title),
                            controlType: exportPropertyRule.flex.controlType(),
                            content: {
                                property: key,
                                newValue: object[key]
                            }
                        };
                        exportResults.flexChanges.push(exportPropertyRule.flex.exportFunction(flexChange, fullManifest));
                    }
                }
                else if (exportPropertyRule.manifest) {
                    let path;
                    if (breadcrumbs[0] === 'sections') {
                        if (breadcrumbs[1] === 'custom') {
                            path = exportPropertyRule.manifest.path(pageKeys, breadcrumbs[2]);
                        }
                        else {
                            path = exportPropertyRule.manifest.path(pageKeys, breadcrumbs[1]);
                            path = path.replace('/@', '::');
                        }
                    }
                    else {
                        path = exportPropertyRule.manifest.path(pageKeys);
                    }
                    manifestSection = manifest_1.getManifestSectionByPathV2(exportResults.manifest, path);
                    const manifestKey = exportPropertyRule.manifest.key || key;
                    if (object[key] !== undefined) {
                        const exportHandler = exportPropertyRule.manifest.export;
                        if (exportHandler !== false) {
                            if (exportHandler && typeof exportHandler === 'function') {
                                exportHandler(manifestSection, object);
                            }
                            else {
                                manifestSection[manifestKey] = object[key];
                            }
                        }
                    }
                    else {
                        if (manifestSection[manifestKey]) {
                            delete manifestSection[manifestKey];
                        }
                        common_1.deleteEmptyStructure(exportResults.manifest, path);
                    }
                }
                continue;
            }
            if (object[key] && typeof object[key] === 'object' && targetDefinition['properties'][key]) {
                let definitionArray;
                if (targetDefinition['properties'][key].$ref) {
                    definitionArray = targetDefinition['properties'][key].$ref.split('#/definitions/');
                }
                else if (targetDefinition['properties'][key]['anyOf']) {
                    definitionArray = targetDefinition['properties'][key]['anyOf'][0].$ref.split('#/definitions/');
                    const definition = targetDefinition['properties'][key]['anyOf'].find((element) => element.$ref.includes(object[key].constructor.name));
                    definitionArray = definition ? [...definition.$ref.split('#/definitions/')] : definitionArray;
                }
                else if (targetDefinition['properties'][key].type === 'array' &&
                    breadcrumbs[0] === 'sections' &&
                    key === 'custom') {
                    transferManifestExtensions(object[key], pageKeys[pageKeys.length - 1], fullManifest, ids, manifest, [...breadcrumbs, key], exportResults, appId, baseId, pageKeys, jsonSchema, targetDefinition['properties'][key].items);
                    continue;
                }
                const nextTargetDefinition = jsonSchema['definitions'][definitionArray[definitionArray.length - 1]];
                const nextTitle = nextTargetDefinition['title'] ? nextTargetDefinition['title'] : title;
                transferManifestEntriesAndFlexChange(fullManifest, object[key], ids, manifest, [...breadcrumbs, key], exportResults, appId, baseId, pageKeys, jsonSchema, nextTargetDefinition, nextTitle);
            }
        }
    }
}
/**
 * Create missing card from the manifest
 * @param key - card name
 * @param cards - all availble cards
 */
function createCard(key, ovp) {
    if (!ovp.cards) {
        ovp.cards = {};
    }
    if (!(key in ovp.cards)) {
        ovp.cards[key] = {};
    }
}
function processProperties(object, manifest, exportResults, jsonSchema, propertyList, pathHierarchy) {
    for (const key in propertyList) {
        const exportPropertyRule = decorators_1.getExportRuleMetadata(object, key);
        if (exportPropertyRule) {
            if (exportPropertyRule.manifest) {
                const path = exportPropertyRule.manifest.path([...pathHierarchy, key]);
                const manifestSection = manifest_1.getManifestSectionByPathV2(exportResults.manifest, path);
                if (key in v2_1.CardSettingsType) {
                    manifestSection['settings'] = object[key] ? object[key] : {};
                }
                else {
                    if (object[key] !== undefined) {
                        manifestSection[key] = object[key];
                    }
                    else if (manifestSection[key]) {
                        delete manifestSection[key];
                    }
                }
            }
        }
        if (object[key] && typeof object[key] === 'object' && propertyList[key]) {
            if (key === 'cards') {
                //inserts and updates:
                Object.keys(object[key]).forEach((newKey) => {
                    const cardType = object[key][newKey].template;
                    switch (cardType) {
                        case Card_1.CardTemplateType.list:
                            object[key][newKey] = Object.assign(new controls_1.ListCard(), object[key][newKey]);
                            break;
                        case Card_1.CardTemplateType.stack:
                            object[key][newKey] = Object.assign(new controls_1.StackCard(), object[key][newKey]);
                            break;
                        case Card_1.CardTemplateType.linklist:
                            object[key][newKey] = Object.assign(new controls_1.LinklistCard(), object[key][newKey]);
                            break;
                        case Card_1.CardTemplateType.table:
                            object[key][newKey] = Object.assign(new controls_1.TableCard(), object[key][newKey]);
                            break;
                        case Card_1.CardTemplateType.analytical:
                            object[key][newKey] = Object.assign(new controls_1.AnalyticalCard(), object[key][newKey]);
                            break;
                        default:
                            object[key][newKey] = Object.assign(new controls_1.CustomCard(), object[key][newKey]);
                            break;
                    }
                    createCard(newKey, exportResults['manifest']['sap.ovp']);
                    let targetDefinition;
                    if (!Object.values(Card_1.CardTemplateType).includes(cardType)) {
                        targetDefinition = ['CustomCard'];
                    }
                    else {
                        targetDefinition = Object.keys(jsonSchema['definitions']).filter((definition) => jsonSchema['definitions'][definition].properties &&
                            jsonSchema['definitions'][definition].properties.template &&
                            jsonSchema['definitions'][definition].properties.template.enum &&
                            jsonSchema['definitions'][definition].properties.template.enum[0] ===
                                object[key][newKey].template);
                    }
                    transferManifestEntriesOVP(object[key][newKey], manifest, exportResults, jsonSchema, jsonSchema['definitions'][targetDefinition[0]], [newKey]);
                });
                //check for deletions:
                Object.keys(manifest['sap.ovp'].cards).forEach((manifestCard) => {
                    if (!object[key][manifestCard]) {
                        delete exportResults.manifest['sap.ovp'].cards[manifestCard];
                    }
                });
            }
            else if (propertyList[key].$ref) {
                const definitionArray = propertyList[key].$ref.split('#/definitions/');
                const nextTargetDefinition = jsonSchema['definitions'][definitionArray[definitionArray.length - 1]];
                const cardSettingsType = key;
                switch (cardSettingsType) {
                    case v2_1.CardSettingsType.listCardSettings:
                        object[key] = Object.assign(new controls_1.ListCard(), object[key]);
                        break;
                    case v2_1.CardSettingsType.stackCardSettings:
                        object[key] = Object.assign(new controls_1.StackCard(), object[key]);
                        break;
                    case v2_1.CardSettingsType.linkListCardSettings:
                        object[key] = Object.assign(new controls_1.LinklistCard(), object[key]);
                        break;
                    case v2_1.CardSettingsType.tableCardSettings:
                        object[key] = Object.assign(new controls_1.TableCard(), object[key]);
                        break;
                    case v2_1.CardSettingsType.analyticalCardSettings:
                        object[key] = Object.assign(new controls_1.AnalyticalCard(), object[key]);
                        break;
                    default:
                        object[key] = Object.assign(new controls_1.CustomCard(), object[key]);
                        break;
                }
                transferManifestEntriesOVP(object[key], manifest, exportResults, jsonSchema, nextTargetDefinition, [
                    ...pathHierarchy,
                    key
                ]);
            }
            else if (propertyList[key].anyOf) {
                processProperties(object, manifest, exportResults, jsonSchema, propertyList[key].anyOf, pathHierarchy);
            }
        }
    }
}
/**
 * Private recursive function that traverses the content of the current object. It reads decorators and fills manifest entries and flex changes
 * @param object - current object to traverse
 * @param manifest - app descriptor (manifest.json)
 * @param exportResults - object with all collected manifest entries and flex changes
 * @param jsonSchema - application specific schema
 * @param pathHierarchy -  small elements of the path indicates hierarchy level from sap.ovp
 */
function transferManifestEntriesOVP(object, manifest, exportResults, jsonSchema, targetDefinition, pathHierarchy) {
    if (targetDefinition) {
        if (targetDefinition['properties']) {
            processProperties(object, manifest, exportResults, jsonSchema, targetDefinition['properties'], pathHierarchy);
        }
        else if (targetDefinition['additionalProperties']) {
            processProperties(object, manifest, exportResults, jsonSchema, targetDefinition['additionalProperties'], pathHierarchy);
        }
    }
}
/**
 * Run through the given ListReport config and return respective manifest entry and flex changes
 * @param appId - id of the Fiori elements app, which is usually namespace.appid
 * @param listReportConfig - content of the src/ListReport_<entity_set>.json file
 * @param entitySet - name of the entity set
 * @param manifest - app descriptor (manifest.json)
 * @param jsonSchema - application specific schema
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
exports.exportListReportPage = (appId, listReportConfig, entitySet, manifest, jsonSchema) => {
    const exportResults = getDefaultExportResult();
    exportResults.flexChanges = [];
    // when assigning a JSON structure to an object structure we need to assign all children, otherwise decorators will not exist
    const listReport = Object.assign(new pages_1.ListReport(), listReportConfig);
    if (listReport.table) {
        switch (listReport.table.type) {
            case v2_1.TableTypeV2.ResponsiveTable:
                listReport.table = Object.assign(new controls_1.ResponsiveTable(), listReport.table);
                break;
            case v2_1.TableTypeV2.TreeTable:
                listReport.table = Object.assign(new controls_1.TreeTable(), listReport.table);
                break;
            case v2_1.TableTypeV2.AnalyticalTable:
                listReport.table = Object.assign(new controls_1.AnalyticalTable(), listReport.table);
                break;
            case v2_1.TableTypeV2.GridTable:
                listReport.table = Object.assign(new controls_1.GridTable(), listReport.table);
                break;
            default:
                listReport.table = Object.assign(new controls_1.ResponsiveTable(), listReport.table);
                break;
        }
        if (listReport.table.columns) {
            const complexIdMatch = new RegExp('DataField.+:::sSmartTableId::listReport.+');
            for (let columnId in listReport.table.columns) {
                if (complexIdMatch.exec(columnId) !== null) {
                    //This part was stripped off during import (table.ts)
                    columnId = 'template:::TableColumn:::' + columnId;
                }
                listReport.table.columns[columnId] = Object.assign(new controls_1.TableColumn(), listReport.table.columns[columnId]);
            }
        }
    }
    listReport.filterBar = Object.assign(new controls_1.FilterBar(), listReport.filterBar);
    const pageLayoutInformation = decorators_1.getPageLayoutInformation(listReport);
    const baseId = `${appId}::${pageLayoutInformation.id}::${entitySet}--`;
    const pageKeys = [];
    const v2Page = utils_1.findListReportPage(manifest['sap.ui.generic.app'].pages, pageKeys);
    if (!v2Page.component.settings) {
        v2Page.component.settings = {};
    }
    exportResults.manifest = manifest;
    transferManifestEntriesAndFlexChange(JSON.parse(JSON.stringify(manifest)), listReport, [], v2Page, [], exportResults, appId, baseId, pageKeys, jsonSchema, jsonSchema //starting point for target definition
    );
    return exportResults;
};
/**
 * Run through the given AnalyticalListPage config and return respective manifest entry and flex changes
 * @param appId - id of the Fiori elements app, which is usually namespace.appid
 * @param analyticalListPageConfig - content of the src/AnalyticalListPage_<entity_set>.json file
 * @param entitySet - name of the entity set
 * @param manifest - app descriptor (manifest.json)
 * @param jsonSchema - application specific schema
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
exports.exportAnalyticalListPage = (appId, analyticalListPageConfig, entitySet, manifest, jsonSchema) => {
    const exportResults = getDefaultExportResult();
    exportResults.flexChanges = [];
    const analyticalListPage = Object.assign(new pages_1.AnalyticalListPage(), analyticalListPageConfig);
    const complexIdMatch = new RegExp('DataField.+:::sSmartTableId::analyticalListPage.+');
    // when assigning a JSON structure to an object structure we need to assign all children, otherwise decorators will not exist
    // find a better way to do this generically, perhaps using the schema?
    analyticalListPage.table = Object.assign(new controls_1.AnalyticalTable(), analyticalListPage.table);
    if (analyticalListPage.table && analyticalListPage.table.columns) {
        for (let columnId in analyticalListPage.table.columns) {
            if (complexIdMatch.exec(columnId) !== null) {
                //This part was stripped off during import (table.ts)
                columnId = 'template:::TableColumn:::' + columnId;
            }
            analyticalListPage.table.columns[columnId] = Object.assign(new controls_1.TableColumn(), analyticalListPage.table.columns[columnId]);
        }
    }
    analyticalListPage.filterBar = Object.assign(new controls_1.FilterBar(), analyticalListPage.filterBar);
    const pageLayoutInformation = decorators_1.getPageLayoutInformation(analyticalListPage);
    const baseId = `${appId}::${pageLayoutInformation.id}::${entitySet}--`;
    const pageKeys = [];
    const v2Page = utils_1.findAnalyticalListPage(manifest['sap.ui.generic.app'].pages, pageKeys);
    v2Page.component.settings = {};
    exportResults.manifest = manifest;
    analyticalListPage.chart = Object.assign(new AnalyticalListPageChart_1.ChartSettings(), analyticalListPage.chart);
    transferManifestEntriesAndFlexChange(JSON.parse(JSON.stringify(manifest)), analyticalListPage, [], v2Page, [], exportResults, appId, baseId, pageKeys, jsonSchema, jsonSchema //starting point for target definition
    );
    return exportResults;
};
/**
 * Run through the given ObjectPage config and return respective manifest entry and flex changes
 * @param appId - id of the Fiori elements app, which is usually namespace.appid
 * @param objectPageConfig - content of the src/ObjectPage_<entity_set>.json file
 * @param entitySet - name of the entity set
 * @param manifest - app descriptor (manifest.json)
 * @param jsonSchema - application specific schema
 * @param entityAnnotations - list of annotations of the entity type that the page is referring to
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
exports.exportObjectPage = (appId, objectPageConfig, entitySet, manifest, jsonSchema) => {
    const exportResults = getDefaultExportResult();
    const objectPage = Object.assign(new pages_1.ObjectPage(), objectPageConfig);
    // when assigning a JSON structure to an object structure we need to assign all children, otherwise decorators will not exist
    // find a better way to do this generically, perhaps using the schema?
    objectPage.header = Object.assign(new controls_1.ObjectPageHeader(), objectPage.header);
    objectPage.layout = Object.assign(new controls_1.ObjectPageLayout(), objectPage.layout);
    const pageLayoutInformation = decorators_1.getPageLayoutInformation(objectPage);
    const baseId = `${appId}::${pageLayoutInformation.id}::${entitySet}--`;
    const pageKeys = [];
    const v2Page = utils_1.findObjectPageinManifest(manifest, entitySet, pageKeys);
    if (!v2Page.component.settings) {
        v2Page.component.settings = {};
    }
    exportResults.manifest = manifest;
    if (objectPageConfig && objectPageConfig.sections) {
        for (const sectionId in objectPageConfig.sections) {
            if (objectPage.sections[sectionId] && objectPage.sections[sectionId].table) {
                const tableType = objectPage.sections[sectionId].table.type;
                switch (tableType) {
                    case 'AnalyticalTable':
                        objectPage.sections[sectionId].table = Object.assign(new controls_1.ObjectPageAnalyticalTable(), objectPage.sections[sectionId].table);
                        break;
                    case 'GridTable':
                        objectPage.sections[sectionId].table = Object.assign(new controls_1.ObjectPageGridTable(), objectPage.sections[sectionId].table);
                        break;
                    case 'TreeTable':
                        objectPage.sections[sectionId].table = Object.assign(new controls_1.ObjectPageTreeTable(), objectPage.sections[sectionId].table);
                        break;
                    default:
                    case 'ResponsiveTable':
                        objectPage.sections[sectionId].table = Object.assign(new controls_1.ObjectPageResponsiveTable(), objectPage.sections[sectionId].table);
                        break;
                }
                if (objectPage.sections[sectionId].table.columns) {
                    for (const columnId in objectPage.sections[sectionId].table.columns) {
                        objectPage.sections[sectionId].table.columns[columnId] = Object.assign(new controls_1.TableColumn(), objectPage.sections[sectionId].table.columns[columnId]);
                    }
                }
            }
            else if (sectionId === 'custom' && Array.isArray(objectPage.sections[sectionId])) {
                // Custom sections
                for (const index in objectPage.sections[sectionId]) {
                    objectPage.sections[sectionId][index] = Object.assign(objectPage.sections[sectionId][index].className === v2_1.SAPUI5_FRAGMENT_CLASS
                        ? new controls_1.ObjectPageCustomSectionFragment()
                        : new controls_1.ObjectPageCustomSectionView(), objectPageConfig.sections[sectionId][index]);
                }
            }
        }
    }
    transferManifestEntriesAndFlexChange(JSON.parse(JSON.stringify(manifest)), objectPage, [], v2Page, [], exportResults, appId, baseId, pageKeys, jsonSchema, jsonSchema //starting point for target definition
    );
    return exportResults;
};
/**
 * Run through the given ObjectPage config and return respective manifest entry and flex changes
 * @param overviewPageConfig - content of the src/OverviewPage_<entity_set>.json file
 * @param manifest - app descriptor (manifest.json)
 * @param jsonSchema - application specific schema
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
exports.exportOverviewPage = (overviewPageConfig, manifest, jsonSchema) => {
    const exportResults = getDefaultExportResult();
    const overviewPage = Object.assign(new pages_1.OverviewPage(), overviewPageConfig);
    overviewPage.cards = Object.assign(new controls_1.CustomCard(), overviewPage.cards);
    exportResults.manifest = manifest;
    transferManifestEntriesOVP(overviewPage, manifest, exportResults, jsonSchema, jsonSchema, []);
    return exportResults;
};
/**
 * Exports a Fiori Element V2 page.
 * It converts the entries of the input page (config file) to corresponding manifest settings and flex changes
 * @param appId - application id
 * @param page - content of the config file of a page
 * @param manifest - app descriptor (manifest.json)
 * @param jsonSchema - application specific schema
 * @param entityAnnotations - list of annotations of the entity type that the page is referring to
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
exports.exportPageV2 = (appId, page, manifest, jsonSchema) => {
    switch (page.pageType) {
        case page_1.PageType.ListReport: {
            return exports.exportListReportPage(appId, page.config, page.entitySet, manifest, jsonSchema);
        }
        case page_1.PageType.ObjectPage: {
            return exports.exportObjectPage(appId, page.config, page.entitySet, manifest, jsonSchema);
        }
        case page_1.PageType.OverviewPage: {
            return exports.exportOverviewPage(page.config, manifest, jsonSchema);
        }
        case page_1.PageType.AnalyticalListPage: {
            return exports.exportAnalyticalListPage(appId, page.config, page.entitySet, manifest, jsonSchema);
        }
    }
};
/**
 * Exports a Fiori Element V2 application.
 * It converts the entries of the input application (config file) to corresponding manifest settings and flex changes
 * @param application - content of the config file of an application
 * @param manifest - app descriptor (manifest.json)
 * @param jsonSchema - application specific schema
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
exports.exportApplicationV2 = (application, manifest, jsonSchema) => {
    const exportResults = getDefaultExportResult();
    exportResults.manifest = manifest;
    const applicationV2 = Object.assign(new application_1.ApplicationV2(), application);
    //transfer application settings
    applicationV2.settings = Object.assign(new application_1.AppSettings(), application['settings']);
    for (const key in jsonSchema['definitions']['AppSettings']['properties']) {
        const exportPropertyRule = decorators_1.getExportRuleMetadata(applicationV2.settings, key);
        if (exportPropertyRule && exportPropertyRule.manifest) {
            const path = exportPropertyRule.manifest.path();
            const manifestSection = manifest_1.getManifestSectionByPathV2(exportResults.manifest, path);
            if (application['settings'] && application['settings'][key]) {
                manifestSection[key] = application['settings'][key];
            }
            else {
                delete manifestSection[key];
            }
        }
    }
    // transfer pages and routings
    const manifestPages = exportResults.manifest['sap.ui.generic.app'] && exportResults.manifest['sap.ui.generic.app'].pages;
    if (manifestPages && application['pages']) {
        manifest_1.transformPageToNewManifestV2(application.home, application['pages'], Object.values(manifestPages)[0]);
    }
    return exportResults;
};
//# sourceMappingURL=export.js.map